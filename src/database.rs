use sqlx::postgres::PgPoolOptions;
use sqlx::{FromRow, Postgres, QueryBuilder};
use std::path::Path;

use chrono::NaiveDateTime;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Settings {
    pub pause_submissions: bool,
}

#[derive(Debug, Clone)]
pub struct AppState {
    pub pool: Arc<sqlx::Pool<Postgres>>,
    pub settings: Arc<tokio::sync::RwLock<Settings>>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize, sqlx::Type)]
#[serde(rename_all = "lowercase")]
#[sqlx(type_name = "TEXT", rename_all = "lowercase")]
pub enum Role {
    User,      // regular user
    Verified,  // verified users can upload thumbnails without approval
    Moderator, // moderators can approve or reject uploads
    Admin,     // admins can manage users and uploads
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Role::User => write!(f, "user"),
            Role::Verified => write!(f, "verified"),
            Role::Moderator => write!(f, "moderator"),
            Role::Admin => write!(f, "admin"),
        }
    }
}

#[derive(Debug, FromRow, Serialize)]
pub struct User {
    pub id: i64,
    pub account_id: i64,
    pub username: String,
    pub role: Role,
    pub discord_id: Option<i64>,
}

#[derive(FromRow)]
pub struct UploadInfo {
    pub account_id: i64,
    pub username: String,
}

#[derive(FromRow, Serialize, Deserialize)]
pub struct UploadExtended {
    pub level_id: i64,
    pub account_id: i64,
    pub username: String,
    pub upload_time: NaiveDateTime,
    pub first_upload_time: NaiveDateTime,
    pub accepted_time: Option<NaiveDateTime>,
    pub accepted_by: Option<i64>,
    pub accepted_by_username: Option<String>,
}

#[derive(Debug, Clone, FromRow, Serialize, Deserialize)]
pub struct PendingUpload {
    pub id: i64,
    pub user_id: i64,
    pub username: String,
    pub level_id: i64,
    pub accepted: bool,
    pub upload_time: NaiveDateTime,

    #[sqlx(skip)]
    pub replacement: bool,
}

#[derive(Debug, Clone)]
pub struct PendingQueryOptions {
    pub page: u32,
    pub per_page: u32,
    pub level_id: Option<i64>,
    pub user_id: Option<i64>,
    pub username: Option<String>,
    pub replacement_only: bool,
    pub new_only: bool,
}

#[derive(Debug, Clone)]
pub struct PendingUploadsPage {
    pub uploads: Vec<PendingUpload>,
    pub total: i64,
}

#[derive(FromRow, Serialize, Deserialize)]
pub struct UserStats {
    pub id: i64,
    pub account_id: i64,
    pub username: String,
    pub role: Role,
    pub upload_count: i64,
    pub accepted_upload_count: i64,
    pub level_count: i64,
    pub accepted_level_count: i64,
    pub active_thumbnail_count: i64,
}

impl AppState {
    pub async fn new() -> Self {
        let connection_string = dotenv::var("DATABASE_URL").expect("DATABASE_URL must be set");
        let pool = PgPoolOptions::new()
            .max_connections(5)
            .connect(&connection_string)
            .await
            .expect("Failed to connect to the database");

        // Run migrations if needed
        sqlx::migrate!("./migrations").run(&pool).await.expect("Failed to run migrations");

        // load settings from state.json or create default
        let settings = if let Ok(settings_data) = tokio::fs::read_to_string("state.json").await {
            serde_json::from_str(&settings_data).unwrap_or(Settings { pause_submissions: false })
        } else {
            Settings { pause_submissions: false }
        };

        AppState {
            pool: Arc::new(pool),
            settings: Arc::new(tokio::sync::RwLock::new(settings)),
        }
    }

    pub async fn get_upload_info(&self, id: i64) -> Option<UploadInfo> {
        sqlx::query_as::<_, UploadInfo>(
            "SELECT users.account_id, users.username
                 FROM uploads
                 JOIN users ON uploads.user_id = users.id
                 WHERE uploads.level_id = $1 AND accepted = TRUE
                 ORDER BY upload_time DESC LIMIT 1",
        )
        .bind(id)
        .fetch_optional(&*self.pool)
        .await
        .ok()?
    }

    pub async fn get_upload_extended(&self, id: i64) -> Option<UploadExtended> {
        sqlx::query_as::<_, UploadExtended>(
            "SELECT 
                    uploads.level_id,
                    users.account_id,
                    users.username,
                    uploads.upload_time,
                    (
                        SELECT MIN(upload_time) FROM uploads u2
                        WHERE u2.level_id = uploads.level_id AND u2.accepted = TRUE
                    ) AS first_upload_time,
                    uploads.accepted_time,
                    accepted_by.account_id AS accepted_by,
                    accepted_by.username AS accepted_by_username
                 FROM uploads
                 JOIN users ON uploads.user_id = users.id
                 LEFT JOIN users AS accepted_by ON uploads.accepted_by = accepted_by.id
                 WHERE uploads.level_id = $1 AND accepted = TRUE
                 ORDER BY upload_time DESC LIMIT 1",
        )
        .bind(id)
        .fetch_optional(&*self.pool)
        .await
        .ok()?
    }

    pub async fn find_or_create_user(
        &self,
        account_id: i64,
        username: &str,
    ) -> Result<User, sqlx::Error> {
        let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE account_id = $1")
            .bind(account_id)
            .bind(username)
            .fetch_optional(&*self.pool)
            .await?;

        if let Some(user) = user {
            Ok(user)
        } else {
            let new_user = sqlx::query_as::<_, User>(
                "INSERT INTO users (account_id, username, role) VALUES ($1, $2, 'user') RETURNING *",
            )
            .bind(account_id)
            .bind(username)
            .fetch_one(&*self.pool)
            .await?;
            Ok(new_user)
        }
    }

    pub async fn find_or_create_user_discord(
        &self,
        discord_id: i64,
        username: &str,
    ) -> Result<User, sqlx::Error> {
        let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE discord_id = $1")
            .bind(discord_id)
            .fetch_optional(&*self.pool)
            .await?;

        if let Some(user) = user {
            Ok(user)
        } else {
            // first check if we can link to existing legacy account
            let legacy_user = sqlx::query_as::<_, User>(
                "SELECT * FROM users WHERE account_id = -1 AND username = $1 AND discord_id IS NULL",
            )
            .bind(username)
            .fetch_optional(&*self.pool)
            .await?;
            if let Some(legacy_user) = legacy_user {
                // update the legacy user with the discord_id
                sqlx::query("UPDATE users SET discord_id = $1 WHERE id = $2")
                    .bind(discord_id)
                    .bind(legacy_user.id)
                    .execute(&*self.pool)
                    .await?;
                return Ok(legacy_user);
            }
            // if no legacy user found, create a new user
            let new_user = sqlx::query_as::<_, User>(
                "INSERT INTO users (account_id, username, role, discord_id) VALUES (-1, $1, 'user', $2) RETURNING *",
            )
            .bind(username)
            .bind(discord_id)
            .fetch_one(&*self.pool)
            .await?;
            Ok(new_user)
        }
    }

    pub async fn get_user_by_id(&self, id: i64) -> Option<User> {
        sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(id)
            .fetch_optional(&*self.pool)
            .await
            .ok()?
    }

    pub async fn add_upload(
        &self,
        level_id: i64,
        user_id: i64,
        image_path: &str,
        accepted: bool,
    ) -> Result<(), sqlx::Error> {
        sqlx::query(if accepted {
            "INSERT INTO uploads (level_id, user_id, image_path, accepted, accepted_time, accepted_by)
                     VALUES ($1, $2, $3, $4, NOW(), $2)"
        } else {
            "INSERT INTO uploads (level_id, user_id, image_path, accepted)
                     VALUES ($1, $2, $3, $4)"
        })
        .bind(level_id)
        .bind(user_id)
        .bind(image_path)
        .bind(accepted)
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    // pub async fn get_pending_uploads(&self) -> Result<Vec<PendingUpload>, sqlx::Error> {
    //     sqlx::query_as::<_, PendingUpload>(
    //         "SELECT uploads.id, user_id, username, level_id, accepted, upload_time FROM uploads
    //          LEFT JOIN users ON users.id = user_id
    //          WHERE accepted = FALSE AND accepted_time IS NULL
    //          ORDER BY upload_time",
    //     )
    //     .fetch_all(&*self.pool)
    //     .await
    // }

    fn apply_pending_filters<'a>(
        builder: &mut QueryBuilder<'a, Postgres>,
        options: &PendingQueryOptions,
    ) {
        if let Some(level_id) = options.level_id {
            builder.push(" AND uploads.level_id = ").push_bind(level_id);
        }

        if let Some(user_id) = options.user_id {
            builder.push(" AND uploads.user_id = ").push_bind(user_id);
        }

        if let Some(ref username) = options.username {
            builder
                .push(" AND LOWER(username) LIKE LOWER(")
                .push_bind(format!("%{}%", username))
                .push(")");
        }
    }

    fn is_image_uploaded(level_id: i64) -> bool {
        let image_path = format!("thumbnails/{}.webp", level_id);
        Path::new(&image_path).exists()
    }

    pub async fn get_pending_uploads_paginated(
        &self,
        options: PendingQueryOptions,
    ) -> Result<PendingUploadsPage, sqlx::Error> {
        if options.replacement_only || options.new_only {
            let mut data_builder = QueryBuilder::new(
                "SELECT uploads.id, user_id, username, level_id, accepted, upload_time FROM uploads
                 LEFT JOIN users ON users.id = user_id
                 WHERE accepted = FALSE AND accepted_time IS NULL",
            );
            Self::apply_pending_filters(&mut data_builder, &options);
            data_builder.push(" ORDER BY upload_time ASC, uploads.id ASC");

            let mut all_uploads =
                data_builder.build_query_as::<PendingUpload>().fetch_all(&*self.pool).await?;

            all_uploads.retain(|upload| {
                let is_uploaded = Self::is_image_uploaded(upload.level_id);
                if options.replacement_only { is_uploaded } else { !is_uploaded }
            });

            let total = all_uploads.len() as i64;
            let per_page = options.per_page as usize;
            let offset = options.page.saturating_sub(1) as usize * per_page;

            let uploads = all_uploads.into_iter().skip(offset).take(per_page).collect();

            Ok(PendingUploadsPage { uploads, total })
        } else {
            let per_page = options.per_page as i64;
            let offset = ((options.page.saturating_sub(1)) as i64) * per_page;

            let mut data_builder = QueryBuilder::new(
                "SELECT uploads.id, user_id, username, level_id, accepted, upload_time FROM uploads
                 LEFT JOIN users ON users.id = user_id
                 WHERE accepted = FALSE AND accepted_time IS NULL",
            );
            Self::apply_pending_filters(&mut data_builder, &options);
            data_builder
                .push(" ORDER BY upload_time ASC, uploads.id ASC LIMIT ")
                .push_bind(per_page)
                .push(" OFFSET ")
                .push_bind(offset);

            let uploads =
                data_builder.build_query_as::<PendingUpload>().fetch_all(&*self.pool).await?;

            let mut count_builder = QueryBuilder::new(
                "SELECT COUNT(*) FROM uploads
                 LEFT JOIN users ON users.id = user_id
                 WHERE accepted = FALSE AND accepted_time IS NULL",
            );
            Self::apply_pending_filters(&mut count_builder, &options);

            let total: i64 = count_builder.build_query_scalar().fetch_one(&*self.pool).await?;

            Ok(PendingUploadsPage { uploads, total })
        }
    }

    // pub async fn get_pending_uploads_for_level(
    //     &self,
    //     level_id: i64,
    // ) -> Result<Vec<PendingUpload>, sqlx::Error> {
    //     sqlx::query_as::<_, PendingUpload>(
    //         "SELECT uploads.id, user_id, username, accepted, upload_time FROM uploads
    //               LEFT JOIN users ON users.id = user_id
    //               WHERE accepted = FALSE AND accepted_time IS NULL AND level_id = $1
    //               ORDER BY upload_time",
    //     )
    //     .bind(level_id)
    //     .fetch_all(&*self.pool)
    //     .await
    // }

    pub async fn get_pending_uploads_for_user(
        &self,
        user_id: i64,
    ) -> Result<Vec<PendingUpload>, sqlx::Error> {
        sqlx::query_as::<_, PendingUpload>(
            "SELECT uploads.id, user_id, username, accepted, upload_time FROM uploads
              LEFT JOIN users ON users.id = user_id
              WHERE accepted = FALSE AND accepted_time IS NULL AND user_id = $1
              ORDER BY upload_time",
        )
        .bind(user_id)
        .fetch_all(&*self.pool)
        .await
    }

    pub async fn get_pending_upload(&self, id: i64) -> Result<PendingUpload, sqlx::Error> {
        sqlx::query_as::<_, PendingUpload>(
            "SELECT uploads.id, user_id, username, level_id, accepted, upload_time FROM uploads
              LEFT JOIN users ON users.id = user_id
              WHERE accepted = FALSE AND accepted_time IS NULL AND uploads.id = $1",
        )
        .bind(id)
        .fetch_one(&*self.pool)
        .await
    }

    pub async fn accept_upload(
        &self,
        id: i64,
        accepted_by: i64,
        reason: Option<String>,
        accept: bool,
    ) -> Result<(), sqlx::Error> {
        sqlx::query(
                 "UPDATE uploads SET accepted = $1, accepted_time = NOW(), accepted_by = $2, reason = $3 WHERE id = $4",
             )
             .bind(accept)
             .bind(accepted_by)
             .bind(reason)
             .bind(id)
             .execute(&*self.pool)
             .await?;
        Ok(())
    }

    pub async fn get_user_stats(&self, id: i64) -> Option<UserStats> {
        sqlx::query_as::<_, UserStats>(
             "SELECT
                 users.id, users.account_id,
                 users.username, users.role,
                 COUNT(uploads.id) AS upload_count,
                 COUNT(DISTINCT uploads.level_id) AS level_count,
                 COUNT(uploads.id) FILTER (WHERE uploads.accepted = TRUE) AS accepted_upload_count,
                 COUNT(DISTINCT uploads.level_id) FILTER (WHERE uploads.accepted = TRUE) AS accepted_level_count,
                 (
                   SELECT COUNT(*)
                   FROM (
                     SELECT u.level_id
                     FROM uploads u
                     WHERE u.accepted = TRUE
                     AND u.user_id = users.id
                     AND u.upload_time = (
                       SELECT MAX(u2.upload_time)
                       FROM uploads u2
                       WHERE u2.level_id = u.level_id
                         AND u2.accepted = TRUE
                     )
                   ) active_levels
                 ) AS active_thumbnail_count
               FROM users
               LEFT JOIN uploads ON users.id = uploads.user_id
               WHERE users.id = $1
               GROUP BY users.id, users.account_id, users.username, users.role",
         )
         .bind(id)
         .fetch_optional(&*self.pool)
         .await
         .ok()?
    }

    pub async fn migrate_user_account(
        &self,
        old_account_id: i64,
        new_account_id: i64,
    ) -> Result<User, sqlx::Error> {
        sqlx::query("CALL migrate($1, $2)")
            .bind(new_account_id)
            .bind(old_account_id)
            .execute(&*self.pool)
            .await?;

        let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(new_account_id)
            .fetch_one(&*self.pool)
            .await?;

        Ok(user)
    }

    pub async fn save_settings(&self) -> Result<(), std::io::Error> {
        let settings = self.settings.read().await;
        let settings_data = serde_json::to_string_pretty(&*settings)?;
        tokio::fs::write("state.json", settings_data).await
    }
}

pub async fn get_db() -> AppState {
    AppState::new().await
}
